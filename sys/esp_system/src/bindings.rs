/* automatically generated by rust-bindgen 0.56.0 */

#![allow(non_camel_case_types, non_upper_case_globals)]

pub type __uint8_t = ::cty::c_uchar;
pub type __int32_t = ::cty::c_int;
pub type __uint32_t = ::cty::c_uint;
pub type esp_err_t = i32;
pub const esp_mac_type_t_ESP_MAC_WIFI_STA: esp_mac_type_t = 0;
pub const esp_mac_type_t_ESP_MAC_WIFI_SOFTAP: esp_mac_type_t = 1;
pub const esp_mac_type_t_ESP_MAC_BT: esp_mac_type_t = 2;
pub const esp_mac_type_t_ESP_MAC_ETH: esp_mac_type_t = 3;
pub type esp_mac_type_t = ::cty::c_uint;
#[doc = "!< Reset reason can not be determined"]
pub const esp_reset_reason_t_ESP_RST_UNKNOWN: esp_reset_reason_t = 0;
#[doc = "!< Reset due to power-on event"]
pub const esp_reset_reason_t_ESP_RST_POWERON: esp_reset_reason_t = 1;
#[doc = "!< Reset by external pin (not applicable for ESP32)"]
pub const esp_reset_reason_t_ESP_RST_EXT: esp_reset_reason_t = 2;
#[doc = "!< Software reset via esp_restart"]
pub const esp_reset_reason_t_ESP_RST_SW: esp_reset_reason_t = 3;
#[doc = "!< Software reset due to exception/panic"]
pub const esp_reset_reason_t_ESP_RST_PANIC: esp_reset_reason_t = 4;
#[doc = "!< Reset (software or hardware) due to interrupt watchdog"]
pub const esp_reset_reason_t_ESP_RST_INT_WDT: esp_reset_reason_t = 5;
#[doc = "!< Reset due to task watchdog"]
pub const esp_reset_reason_t_ESP_RST_TASK_WDT: esp_reset_reason_t = 6;
#[doc = "!< Reset due to other watchdogs"]
pub const esp_reset_reason_t_ESP_RST_WDT: esp_reset_reason_t = 7;
#[doc = "!< Reset after exiting deep sleep mode"]
pub const esp_reset_reason_t_ESP_RST_DEEPSLEEP: esp_reset_reason_t = 8;
#[doc = "!< Brownout reset (software or hardware)"]
pub const esp_reset_reason_t_ESP_RST_BROWNOUT: esp_reset_reason_t = 9;
#[doc = "!< Reset over SDIO"]
pub const esp_reset_reason_t_ESP_RST_SDIO: esp_reset_reason_t = 10;
#[doc = " @brief Reset reasons"]
pub type esp_reset_reason_t = ::cty::c_uint;
#[doc = " Shutdown handler type"]
pub type shutdown_handler_t = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
  #[doc = " @brief  Register shutdown handler"]
  #[doc = ""]
  #[doc = " This function allows you to register a handler that gets invoked before"]
  #[doc = " the application is restarted using esp_restart function."]
  #[doc = " @param handle function to execute on restart"]
  #[doc = " @return"]
  #[doc = "   - ESP_OK on success"]
  #[doc = "   - ESP_ERR_INVALID_STATE if the handler has already been registered"]
  #[doc = "   - ESP_ERR_NO_MEM if no more shutdown handler slots are available"]
  pub fn esp_register_shutdown_handler(handle: shutdown_handler_t) -> esp_err_t;
}
extern "C" {
  #[doc = " @brief  Unregister shutdown handler"]
  #[doc = ""]
  #[doc = " This function allows you to unregister a handler which was previously"]
  #[doc = " registered using esp_register_shutdown_handler function."]
  #[doc = "   - ESP_OK on success"]
  #[doc = "   - ESP_ERR_INVALID_STATE if the given handler hasn't been registered before"]
  pub fn esp_unregister_shutdown_handler(handle: shutdown_handler_t) -> esp_err_t;
}
extern "C" {
  #[doc = " @brief  Restart PRO and APP CPUs."]
  #[doc = ""]
  #[doc = " This function can be called both from PRO and APP CPUs."]
  #[doc = " After successful restart, CPU reset reason will be SW_CPU_RESET."]
  #[doc = " Peripherals (except for WiFi, BT, UART0, SPI1, and legacy timers) are not reset."]
  #[doc = " This function does not return."]
  pub fn esp_restart();
}
extern "C" {
  #[doc = " @brief  Get reason of last reset"]
  #[doc = " @return See description of esp_reset_reason_t for explanation of each value."]
  pub fn esp_reset_reason() -> esp_reset_reason_t;
}
extern "C" {
  #[doc = " @brief  Get the size of available heap."]
  #[doc = ""]
  #[doc = " Note that the returned value may be larger than the maximum contiguous block"]
  #[doc = " which can be allocated."]
  #[doc = ""]
  #[doc = " @return Available heap size, in bytes."]
  pub fn esp_get_free_heap_size() -> u32;
}
extern "C" {
  #[doc = " @brief  Get the size of available internal heap."]
  #[doc = ""]
  #[doc = " Note that the returned value may be larger than the maximum contiguous block"]
  #[doc = " which can be allocated."]
  #[doc = ""]
  #[doc = " @return Available internal heap size, in bytes."]
  pub fn esp_get_free_internal_heap_size() -> u32;
}
extern "C" {
  #[doc = " @brief Get the minimum heap that has ever been available"]
  #[doc = ""]
  #[doc = " @return Minimum free heap ever available"]
  pub fn esp_get_minimum_free_heap_size() -> u32;
}
extern "C" {
  #[doc = " @brief  Get one random 32-bit word from hardware RNG"]
  #[doc = ""]
  #[doc = " The hardware RNG is fully functional whenever an RF subsystem is running (ie Bluetooth or WiFi is enabled). For"]
  #[doc = " random values, call this function after WiFi or Bluetooth are started."]
  #[doc = ""]
  #[doc = " If the RF subsystem is not used by the program, the function bootloader_random_enable() can be called to enable an"]
  #[doc = " entropy source. bootloader_random_disable() must be called before RF subsystem or I2S peripheral are used. See these functions'"]
  #[doc = " documentation for more details."]
  #[doc = ""]
  #[doc = " Any time the app is running without an RF subsystem (or bootloader_random) enabled, RNG hardware should be"]
  #[doc = " considered a PRNG. A very small amount of entropy is available due to pre-seeding while the IDF"]
  #[doc = " bootloader is running, but this should not be relied upon for any use."]
  #[doc = ""]
  #[doc = " @return Random value between 0 and UINT32_MAX"]
  pub fn esp_random() -> u32;
}
extern "C" {
  #[doc = " @brief Fill a buffer with random bytes from hardware RNG"]
  #[doc = ""]
  #[doc = " @note This function has the same restrictions regarding available entropy as esp_random()"]
  #[doc = ""]
  #[doc = " @param buf Pointer to buffer to fill with random numbers."]
  #[doc = " @param len Length of buffer in bytes"]
  pub fn esp_fill_random(buf: *mut ::cty::c_void, len: usize);
}
extern "C" {
  #[doc = " @brief  Set base MAC address with the MAC address which is stored in BLK3 of EFUSE or"]
  #[doc = "         external storage e.g. flash and EEPROM."]
  #[doc = ""]
  #[doc = " Base MAC address is used to generate the MAC addresses used by the networking interfaces."]
  #[doc = " If using base MAC address stored in BLK3 of EFUSE or external storage, call this API to set base MAC"]
  #[doc = " address with the MAC address which is stored in BLK3 of EFUSE or external storage before initializing"]
  #[doc = " WiFi/BT/Ethernet."]
  #[doc = ""]
  #[doc = " @note Base MAC must be a unicast MAC (least significant bit of first byte must be zero)."]
  #[doc = ""]
  #[doc = " @note If not using a valid OUI, set the \"locally administered\" bit"]
  #[doc = "       (bit value 0x02 in the first byte) to avoid collisions."]
  #[doc = ""]
  #[doc = " @param  mac  base MAC address, length: 6 bytes."]
  #[doc = ""]
  #[doc = " @return ESP_OK on success"]
  #[doc = "         ESP_ERR_INVALID_ARG If mac is NULL or is not a unicast MAC"]
  pub fn esp_base_mac_addr_set(mac: *const u8) -> esp_err_t;
}
extern "C" {
  #[doc = " @brief  Return base MAC address which is set using esp_base_mac_addr_set."]
  #[doc = ""]
  #[doc = " @param  mac  base MAC address, length: 6 bytes."]
  #[doc = ""]
  #[doc = " @return ESP_OK on success"]
  #[doc = "         ESP_ERR_INVALID_MAC base MAC address has not been set"]
  pub fn esp_base_mac_addr_get(mac: *mut u8) -> esp_err_t;
}
extern "C" {
  #[doc = " @brief  Return base MAC address which was previously written to BLK3 of EFUSE."]
  #[doc = ""]
  #[doc = " Base MAC address is used to generate the MAC addresses used by the networking interfaces."]
  #[doc = " This API returns the custom base MAC address which was previously written to BLK3 of EFUSE."]
  #[doc = " Writing this EFUSE allows setting of a different (non-Espressif) base MAC address. It is also"]
  #[doc = " possible to store a custom base MAC address elsewhere, see esp_base_mac_addr_set() for details."]
  #[doc = ""]
  #[doc = " @param  mac  base MAC address, length: 6 bytes."]
  #[doc = ""]
  #[doc = " @return ESP_OK on success"]
  #[doc = "         ESP_ERR_INVALID_VERSION An invalid MAC version field was read from BLK3 of EFUSE"]
  #[doc = "         ESP_ERR_INVALID_CRC An invalid MAC CRC was read from BLK3 of EFUSE"]
  pub fn esp_efuse_mac_get_custom(mac: *mut u8) -> esp_err_t;
}
extern "C" {
  #[doc = " @brief  Return base MAC address which is factory-programmed by Espressif in BLK0 of EFUSE."]
  #[doc = ""]
  #[doc = " @param  mac  base MAC address, length: 6 bytes."]
  #[doc = ""]
  #[doc = " @return ESP_OK on success"]
  pub fn esp_efuse_mac_get_default(mac: *mut u8) -> esp_err_t;
}
extern "C" {
  #[doc = " @brief  Read base MAC address and set MAC address of the interface."]
  #[doc = ""]
  #[doc = " This function first get base MAC address using esp_base_mac_addr_get or reads base MAC address"]
  #[doc = " from BLK0 of EFUSE. Then set the MAC address of the interface including wifi station, wifi softap,"]
  #[doc = " bluetooth and ethernet."]
  #[doc = ""]
  #[doc = " @param  mac  MAC address of the interface, length: 6 bytes."]
  #[doc = " @param  type  type of MAC address, 0:wifi station, 1:wifi softap, 2:bluetooth, 3:ethernet."]
  #[doc = ""]
  #[doc = " @return ESP_OK on success"]
  pub fn esp_read_mac(mac: *mut u8, type_: esp_mac_type_t) -> esp_err_t;
}
extern "C" {
  #[doc = " @brief Derive local MAC address from universal MAC address."]
  #[doc = ""]
  #[doc = " This function derives a local MAC address from an universal MAC address."]
  #[doc = " A `definition of local vs universal MAC address can be found on Wikipedia"]
  #[doc = " <https://en.wikipedia.org/wiki/MAC_address#Universal_vs._local>`."]
  #[doc = " In ESP32, universal MAC address is generated from base MAC address in EFUSE or other external storage."]
  #[doc = " Local MAC address is derived from the universal MAC address."]
  #[doc = ""]
  #[doc = " @param  local_mac  Derived local MAC address, length: 6 bytes."]
  #[doc = " @param  universal_mac  Source universal MAC address, length: 6 bytes."]
  #[doc = ""]
  #[doc = " @return ESP_OK on success"]
  pub fn esp_derive_local_mac(local_mac: *mut u8, universal_mac: *const u8) -> esp_err_t;
}
extern "C" {
  #[doc = " @brief Trigger a software abort"]
  #[doc = ""]
  #[doc = " @param details Details that will be displayed during panic handling."]
  pub fn esp_system_abort(details: *const ::cty::c_char);
}
#[doc = "!< ESP32"]
pub const esp_chip_model_t_CHIP_ESP32: esp_chip_model_t = 1;
#[doc = "!< ESP32-S2"]
pub const esp_chip_model_t_CHIP_ESP32S2: esp_chip_model_t = 2;
#[doc = " @brief Chip models"]
pub type esp_chip_model_t = ::cty::c_uint;
#[doc = " @brief The structure represents information about the chip"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_chip_info_t {
  #[doc = "!< chip model, one of esp_chip_model_t"]
  pub model: esp_chip_model_t,
  #[doc = "!< bit mask of CHIP_FEATURE_x feature flags"]
  pub features: u32,
  #[doc = "!< number of CPU cores"]
  pub cores: u8,
  #[doc = "!< chip revision number"]
  pub revision: u8,
}
#[test]
fn bindgen_test_layout_esp_chip_info_t() {
  assert_eq!(
    ::core::mem::size_of::<esp_chip_info_t>(),
    12usize,
    concat!("Size of: ", stringify!(esp_chip_info_t))
  );
  assert_eq!(
    ::core::mem::align_of::<esp_chip_info_t>(),
    4usize,
    concat!("Alignment of ", stringify!(esp_chip_info_t))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<esp_chip_info_t>())).model as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(esp_chip_info_t),
      "::",
      stringify!(model)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<esp_chip_info_t>())).features as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(esp_chip_info_t),
      "::",
      stringify!(features)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<esp_chip_info_t>())).cores as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(esp_chip_info_t),
      "::",
      stringify!(cores)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<esp_chip_info_t>())).revision as *const _ as usize },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(esp_chip_info_t),
      "::",
      stringify!(revision)
    )
  );
}
extern "C" {
  #[doc = " @brief Fill an esp_chip_info_t structure with information about the chip"]
  #[doc = " @param[out] out_info structure to be filled"]
  pub fn esp_chip_info(out_info: *mut esp_chip_info_t);
}
